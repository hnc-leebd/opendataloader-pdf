name: "Stage 2: Deep Triage"

on:
  issues:
    types: [labeled]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number

env:
  DAILY_LIMIT: 5

jobs:
  deep-triage:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      actions: read

    # Run when:
    # 1. workflow_dispatch (manual)
    # 2. triage/valid label added (from Stage 1)
    # 3. comment on issue with triage/question label (user responded)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && github.event.label.name == 'triage/valid') ||
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'triage/question'))

    steps:
      - name: Check preconditions
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get issue number based on event type
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ISSUE_NUM=${{ inputs.issue_number }}
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            ISSUE_NUM=${{ github.event.issue.number }}
          else
            ISSUE_NUM=${{ github.event.issue.number }}
          fi
          echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT

          # Check daily limit
          TODAY=$(date -u +%Y-%m-%d)
          COUNT=$(gh api \
            "/repos/${{ github.repository }}/actions/workflows/ai-triage-2-deep.yml/runs?status=success&created=>=$TODAY" \
            --jq '.total_count')

          echo "Today's runs: $COUNT / $DAILY_LIMIT"
          if [ "$COUNT" -ge "$DAILY_LIMIT" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "reason=Daily limit reached ($COUNT/$DAILY_LIMIT)" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if already deep-triaged
          LABELS=$(gh issue view $ISSUE_NUM --repo ${{ github.repository }} --json labels --jq '.labels[].name')
          if echo "$LABELS" | grep -q "triage/deep"; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "reason=Already deep-triaged" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if valid or question (passed Stage 1)
          if ! echo "$LABELS" | grep -qE "triage/valid|triage/question"; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "reason=Issue not marked as triage/valid or triage/question (Stage 1 not passed)" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Skip notification
        if: steps.check.outputs.skip == 'true'
        run: |
          echo "âš ï¸ Skipping: ${{ steps.check.outputs.reason }}"

      - uses: actions/checkout@v4
        if: steps.check.outputs.skip != 'true'

      - name: Setup Node.js
        if: steps.check.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Gather context
        if: steps.check.outputs.skip != 'true'
        id: context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_number }}

          # Get full issue details
          gh issue view $ISSUE_NUM --json title,body,labels,comments > /tmp/issue.json

      - name: Run Claude Code - Analysis
        if: steps.check.outputs.skip != 'true'
        id: analysis
        timeout-minutes: 15
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_number }}
          ISSUE_JSON=$(cat /tmp/issue.json)

          # Claude Code will automatically load context from .claude/skills/workflows-ai-triage/
          PROMPT=$(cat <<'PROMPT_EOF'
          Perform deep triage for GitHub issue #ISSUE_NUM_PLACEHOLDER using the workflows-ai-triage skill.

          ## Issue Details
          ISSUE_JSON_PLACEHOLDER

          ## Instructions
          Use the workflows-ai-triage skill to:
          1. Read the skill files in .claude/skills/workflows-ai-triage/ for policies and criteria
          2. **Analyze the codebase** to understand:
             - What the issue is about
             - Which files/components are involved
             - How the current implementation works
          3. Decide action: "auto_fix" or "assign"
             - Use ai-fix-criteria.md to determine if auto-fix is appropriate
          4. Select appropriate labels, priority, and estimate based on issue-policy.md
          5. Recommend the best available team member from members.md

          ## Required Output
          Respond with JSON only (no markdown code blocks):
          {
            "action": "auto_fix" | "assign",
            "labels": ["label1", "label2"],
            "priority": "P0" | "P1" | "P2",
            "estimated": 1 | 2 | 3 | 5 | 8,
            "assignee": "github_id",
            "analysis": {
              "summary": "One paragraph summary of what this issue is about",
              "expected_behavior": "What the user expects to happen",
              "current_behavior": "What currently happens (if applicable)",
              "affected_files": ["path/to/file1.ts", "path/to/file2.ts"],
              "root_cause": "Technical explanation of why the issue occurs (if identifiable)",
              "suggested_approach": "How to fix or implement this"
            },
            "auto_fix_rationale": "Why this is/isn't suitable for auto-fix (reference ai-fix-criteria.md)"
          }
          PROMPT_EOF
          )

          # Replace placeholders
          PROMPT="${PROMPT//ISSUE_NUM_PLACEHOLDER/$ISSUE_NUM}"
          PROMPT="${PROMPT//ISSUE_JSON_PLACEHOLDER/$ISSUE_JSON}"

          # Save prompt to file (avoid argument length limits)
          echo "$PROMPT" > /tmp/analysis_prompt.txt

          RESULT=$(cat /tmp/analysis_prompt.txt | npx -y @anthropic-ai/claude-code \
            --print \
            --verbose \
            --allowedTools "Read,Glob,Grep" \
            2>&1 || echo '{}')

          echo "=== Analysis Result ==="
          echo "$RESULT"
          echo "======================="

          # Extract JSON from result (handle ```json wrapper if present)
          PARSED_JSON=$(echo "$RESULT" | sed -n '/```json/,/```/p' | sed '1d;$d')
          if [ -z "$PARSED_JSON" ]; then
            # Try to extract raw JSON object (multiline)
            PARSED_JSON=$(echo "$RESULT" | awk '/^{/,/^}/' | head -100)
          fi
          if [ -z "$PARSED_JSON" ]; then
            PARSED_JSON='{}'
          fi

          echo "=== Parsed JSON ==="
          echo "$PARSED_JSON"
          echo "==================="

          # Parse JSON fields
          ACTION=$(echo "$PARSED_JSON" | jq -r '.action // "assign"')
          LABELS=$(echo "$PARSED_JSON" | jq -c '.labels // []')
          PRIORITY=$(echo "$PARSED_JSON" | jq -r '.priority // "P2"')
          ESTIMATED=$(echo "$PARSED_JSON" | jq -r '.estimated // 3')
          ASSIGNEE=$(echo "$PARSED_JSON" | jq -r '.assignee // ""' | tr -d '@')
          AUTO_FIX_RATIONALE=$(echo "$PARSED_JSON" | jq -r '.auto_fix_rationale // ""')

          # Extract analysis fields
          ANALYSIS_SUMMARY=$(echo "$PARSED_JSON" | jq -r '.analysis.summary // "Unable to analyze"')
          EXPECTED_BEHAVIOR=$(echo "$PARSED_JSON" | jq -r '.analysis.expected_behavior // ""')
          CURRENT_BEHAVIOR=$(echo "$PARSED_JSON" | jq -r '.analysis.current_behavior // ""')
          AFFECTED_FILES=$(echo "$PARSED_JSON" | jq -r '.analysis.affected_files // [] | join(", ")')
          ROOT_CAUSE=$(echo "$PARSED_JSON" | jq -r '.analysis.root_cause // ""')
          SUGGESTED_APPROACH=$(echo "$PARSED_JSON" | jq -r '.analysis.suggested_approach // ""')

          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "labels=$LABELS" >> $GITHUB_OUTPUT
          echo "priority=$PRIORITY" >> $GITHUB_OUTPUT
          echo "estimated=$ESTIMATED" >> $GITHUB_OUTPUT
          echo "assignee=$ASSIGNEE" >> $GITHUB_OUTPUT

          # Save analysis to files for comment construction
          echo "$ANALYSIS_SUMMARY" > /tmp/analysis_summary.txt
          echo "$EXPECTED_BEHAVIOR" > /tmp/expected_behavior.txt
          echo "$CURRENT_BEHAVIOR" > /tmp/current_behavior.txt
          echo "$AFFECTED_FILES" > /tmp/affected_files.txt
          echo "$ROOT_CAUSE" > /tmp/root_cause.txt
          echo "$SUGGESTED_APPROACH" > /tmp/suggested_approach.txt
          echo "$AUTO_FIX_RATIONALE" > /tmp/auto_fix_rationale.txt

      - name: Post Analysis Comment
        if: steps.check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ASSIGNEE: ${{ steps.analysis.outputs.assignee }}
          PRIORITY: ${{ steps.analysis.outputs.priority }}
          ESTIMATED: ${{ steps.analysis.outputs.estimated }}
          ACTION: ${{ steps.analysis.outputs.action }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_number }}

          # Read analysis from files
          SUMMARY=$(cat /tmp/analysis_summary.txt)
          EXPECTED=$(cat /tmp/expected_behavior.txt)
          CURRENT=$(cat /tmp/current_behavior.txt)
          FILES=$(cat /tmp/affected_files.txt)
          ROOT_CAUSE=$(cat /tmp/root_cause.txt)
          APPROACH=$(cat /tmp/suggested_approach.txt)
          AUTO_FIX_RATIONALE=$(cat /tmp/auto_fix_rationale.txt)

          # Build conditional sections
          EXPECTED_SECTION=""
          if [ -n "$EXPECTED" ]; then
            EXPECTED_SECTION="### Expected Behavior
          $EXPECTED"
          fi

          CURRENT_SECTION=""
          if [ -n "$CURRENT" ]; then
            CURRENT_SECTION="### Current Behavior
          $CURRENT"
          fi

          ROOT_CAUSE_SECTION=""
          if [ -n "$ROOT_CAUSE" ]; then
            ROOT_CAUSE_SECTION="### Root Cause
          $ROOT_CAUSE"
          fi

          # Determine action badge
          if [ "$ACTION" = "auto_fix" ]; then
            ACTION_BADGE="ðŸ¤– **Auto-fix eligible** - Stage 3 can attempt automatic fix"
          else
            ACTION_BADGE="ðŸ‘¤ **Manual fix required** - Assigned for human implementation"
          fi

          COMMENT=$(cat <<EOF
          ## ðŸ” AI Deep Analysis

          ### Summary
          $SUMMARY

          $EXPECTED_SECTION

          $CURRENT_SECTION

          ### Affected Files
          \`$FILES\`

          $ROOT_CAUSE_SECTION

          ### Suggested Approach
          $APPROACH

          ---

          ## ðŸ“‹ Triage Decision

          $ACTION_BADGE

          | Field | Value |
          |-------|-------|
          | **Priority** | $PRIORITY |
          | **Estimate** | $ESTIMATED story points |
          | **Assignee** | @$ASSIGNEE |

          <details>
          <summary>Auto-fix rationale</summary>

          $AUTO_FIX_RATIONALE

          </details>

          ---
          ðŸ¤– *This analysis was generated by AI and may be inaccurate or inappropriate. If something seems off, please let us know!*
          EOF
          )

          gh issue comment $ISSUE_NUM --body "$COMMENT"

          # Assign to recommended member
          if [ -n "$ASSIGNEE" ]; then
            gh issue edit $ISSUE_NUM --add-assignee "$ASSIGNEE" || echo "Failed to assign to $ASSIGNEE"
          fi

      - name: Update Labels
        if: steps.check.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LABELS: ${{ steps.analysis.outputs.labels }}
          ACTION: ${{ steps.analysis.outputs.action }}
          PRIORITY: ${{ steps.analysis.outputs.priority }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_number }}

          # Build label arguments
          LABEL_ARGS=""
          for label in $(echo "$LABELS" | jq -r '.[]'); do
            # Convert old labels to new format (type/*)
            case "$label" in
              bug) LABEL_ARGS="$LABEL_ARGS --add-label \"type/bug\"" ;;
              enhancement) LABEL_ARGS="$LABEL_ARGS --add-label \"type/enhancement\"" ;;
              documentation) LABEL_ARGS="$LABEL_ARGS --add-label \"type/docs\"" ;;
              dependencies) LABEL_ARGS="$LABEL_ARGS --add-label \"type/dependencies\"" ;;
              *) LABEL_ARGS="$LABEL_ARGS --add-label \"$label\"" ;;
            esac
          done

          # Add priority label (priority/P0, priority/P1, priority/P2)
          LABEL_ARGS="$LABEL_ARGS --add-label \"priority/$PRIORITY\""

          # Add fix/auto-eligible label if applicable
          if [ "$ACTION" = "auto_fix" ]; then
            LABEL_ARGS="$LABEL_ARGS --add-label \"fix/auto-eligible\""
          fi

          # Add triage/deep label
          LABEL_ARGS="$LABEL_ARGS --add-label \"triage/deep\""

          eval gh issue edit $ISSUE_NUM $LABEL_ARGS

      - name: Trigger Stage 3 (if auto-fixable)
        if: steps.check.outputs.skip != 'true' && steps.analysis.outputs.action == 'auto_fix'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_number }}

          echo "âœ… Issue #$ISSUE_NUM is eligible for auto-fix"
          echo "Has fix/auto-eligible label - Stage 3 can be triggered manually:"
          echo "  gh workflow run ai-triage-3-fix.yml -f issue_number=$ISSUE_NUM"
